var t, e; t = document.currentScript.src, e = { txt1: "Web Components", txt2: "Questions", txt3: "<web-components-banner>", txt4: "", txt5: "Build Web Components, Learn Web Components", txt6: "shadowDOM-Custom Elements-templates".replaceAll("-", "&nbsp;".repeat(4)), width: 10, height: 130, handle: 0, txt1y: 70, txt2y: 70, txt3y: 118, txt4y: 118, txt5y: 28, txt1size: 70, txt2size: 70, txt3size: 35, txt4size: 35, txt5size: 13, txt6size: 13, txt1x: 1, txt2x: 99, txt3x: 1, txt4x: 99, txt5x: 23, txt6x: 1, durtag: 4, durlogo: 40, txt1fill: "#b8860b", txt2fill: "#b8860b", txt3fill: "#006400", txt4fill: "#ff6400", txt5fill: "#006400", txt6fill: "#eeeeee", txt1stroke: "#006400", txt2stroke: "#006400", txt1anchor: "start", txt2anchor: "end", txt3anchor: "start", txt4anchor: "end", txt5anchor: "start", txt6anchor: "start", repeattag: "once", repeatlogo: "indefinite" }, new URLSearchParams(location.search + "&" + t.split("?")[1]).forEach(((t, r) => e[r] = t)), customElements.define("web-components-banner", class extends HTMLElement { static observedAttributes = Object.keys(e); attributeChangedCallback(t, r, s) { this.do ? this[t] = s : e[t] = s } connectedCallback(r = (t = t => `var(--${t},${this[t]})`, e = (e, r = "M0 100h1100", s = "txt" + e, o = this[s].replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/_/g, " ")) => ("txt2" == s && "Q" == o[0] ? (this.handle = 0, o = o.slice(1)) : "txt2" == s && (this.handle = 90), `<path part=${s}y fill=none id=${s} pathLength=100 d="${r}"/><text><textPath href=#${s} part=${s} font-size=${t(s + "size")} fill=${t(s + "fill")} stroke=${t(s + "stroke")} startoffset=${this[s + "x"]} text-anchor=${this[s + "anchor"]} >${o}</textPath></text>`), r = ({ type: t = "rotate", from: e = 360, to: r = 0, repeat: s, dur: o = 2 }) => `<animateTransform type=${t} attributeType=xml attributeName=transform additive=sum repeatCount=${s} dur=${o} from="${e + ("rotate" == t ? " 50 50" : 0)}" to="${r + ("rotate" == t ? " 50 50" : 0)}"/>`, s = t => this.shadowRoot.querySelector(`[part=${t}]`), o = t => ~~s(t).getBBox().width) => { this.do = 0, this.shadowRoot.innerHTML = '<style>:host{display:inline-block;width:100%}[part=txt3]{text-shadow:1px 1px 2px black}</style><svg part=svg viewBox="0 0 120 120"><g>' + e(1) + e(2) + "<g part=logo>" + `<g stroke-width=14 stroke-linecap=round transform="rotate(${this.handle} 50 50)">` + `<line x1=80 y1=80 x2=120 y2=120 stroke=${t("txt1fill")} />` + `<line x1=85 y1=85 x2=120 y2=120 stroke=${t("txt1stroke")} stroke-width=2 />` + `<circle part=circle fill=none cx=50 cy=50 r=41 stroke=${t("txt1fill")} />` + `<circle fill=none cx=50 cy=50 r=48 stroke=${t("txt1stroke")} stroke-width=2 /></g>` + `<path stroke-width=4 stroke=${t("txt1stroke")} stroke-linecap=round fill=none d="M40 50H60M35 60 25 50 35 40M65 60 75 50 65 40">` + r({ repeat: this.repeattag, dur: this.durtag, from: 180 }) + "</path><g>" + e(6, "M50 50 m-45 0 a45 45 0 1 0 90,0 a45 45 0 1 0 -90 0") + r({ repeat: this.repeatlogo, dur: this.durlogo, from: -360 }) + "</g></g>" + e(3) + e(4) + e(5) + "</svg>", this.width = o("txt1") + o("circle") + o("txt2") + 75 + (this.handle ? 20 : 0), s("svg").setAttribute("viewBox", `0 0 ${this.width} ${this.height}`), [1, 2, 3, 4, 5].map((t => s("txt" + t + "y").setAttribute("d", `M0 ${this["txt" + t + "y"]}h` + this.width))), s("logo").setAttribute("transform", `translate(${o("txt1") + 40} 0)`), this.do = 1 }) { this.$ = Object.keys(e).map((t => Object.defineProperty(this, t, { get: r => e[t], set: s => (e[t] = s, this.do && r()) }))), this.min = t.includes(".min"), this.attachShadow({ mode: "open" }), r() } });